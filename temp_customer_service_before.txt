"use strict";

import { Op, fn, col, literal } from "sequelize";
import db from "../../models/index.js";
import { ensureProductImageColumns, ensureNewsImageColumns } from "../../utils/schemaEnsurer.js";
import { mapImageFields } from "../../utils/imageMapper.js";
import { isMissingColumnError, isMissingTableError } from "../../utils/dbErrors.js";

const {
  sequelize,
  User,
  Order,
  OrderItem,
  Product,
  Promotion,
  News,
  Cart,
  CartItem,
  Message,
  Conversation,
  ChatMessage
} = db;

class CustomerServiceError extends Error {
  constructor(message, statusCode = 400, code = "CUSTOMER_SERVICE_ERROR", metadata = {}) {
    super(message);
    this.name = "CustomerServiceError";
    this.statusCode = statusCode;
    this.code = code;
    this.metadata = metadata;
  }
}

const toPlain = (item) => (item?.get ? item.get({ plain: true }) : item);

const mapProductImage = (product) => {
  if (!product) return product;
  const plain = product?.get ? product.get({ plain: true }) : product;
  return mapImageFields(plain);
};

const resolveProductImageAttributes = (supportsBlob) => {
  const attrs = ["product_id", "name", "price", "image_url", "food_type"];
  if (supportsBlob) {
    attrs.splice(3, 0, "image_data", "image_mime");
  }
  return attrs;
};

const excludeImageColumnsWhenUnsupported = (supportsBlob) =>
  supportsBlob ? undefined : { exclude: ["image_data", "image_mime"] };

const ensureCustomerUser = async (userId) => {
  const user = await User.findByPk(userId);
  if (!user) {
    throw new CustomerServiceError("Khong tim thay nguoi dung", 404, "USER_NOT_FOUND");
  }
  if (!["customer", "admin"].includes(user.role)) {
    throw new CustomerServiceError("Vai tro khong duoc phep thuc hien thao tac nay", 403, "ROLE_NOT_ALLOWED");
  }
  return user;
};

const PROFILE_FIELDS = ["full_name", "phone_number", "address", "gender"];
const VALID_GENDERS = new Set(["male", "female", "other", "unknown"]);

const sanitizeProfileFields = (payload = {}) => {
  const result = {};
  PROFILE_FIELDS.forEach((field) => {
    if (!Object.prototype.hasOwnProperty.call(payload, field)) {
      return;
    }
    const value = payload[field];
    if (field === "gender") {
      if (value === null || value === undefined) {
        result[field] = "unknown";
        return;
      }
      const normalized = typeof value === "string" ? value.trim().toLowerCase() : value;
      result[field] = VALID_GENDERS.has(normalized) ? normalized : "unknown";
      return;
    }
    if (value === null || value === undefined) {
      result[field] = null;
      return;
    }
    if (typeof value === "string") {
      const trimmed = value.trim();
      result[field] = trimmed.length ? trimmed : null;
      return;
    }
    result[field] = value;
  });
  return result;
};

const hasMeaningfulProfileValue = (payload = {}) =>
  PROFILE_FIELDS.some((field) => {
    if (!Object.prototype.hasOwnProperty.call(payload, field)) {
      return false;
    }
    const value = payload[field];
    if (field === "gender") {
      return Boolean(value) && value !== "unknown";
    }
    if (value === null || value === undefined) {
      return false;
    }
    if (typeof value === "string") {
      return value.trim().length > 0;
    }
    return true;
  });

const profileHasStoredDetails = (user) =>
  Boolean(
    user?.full_name ||
      user?.phone_number ||
      user?.address ||
      (user?.gender && user.gender !== "unknown")
  );

const listActiveProducts = async ({ search, categoryId, limit } = {}) => {
  const supportsBlob = (await ensureProductImageColumns()) !== false;
  const where = {};
  if (categoryId) {
    where.category_id = Number(categoryId);
  }
  if (search) {
    where.name = { [Op.like]: `%${search.trim()}%` };
  }

  const options = {
    where,
    include: [{ model: db.ProductOption, as: "options" }],
    order: [["updated_at", "DESC"]]
  };

  if (limit) {
    const parsedLimit = Number(limit);
    if (!Number.isNaN(parsedLimit) && parsedLimit > 0) {
      options.limit = Math.min(parsedLimit, 50);
    }
  }

  if (!supportsBlob) {
    options.attributes = excludeImageColumnsWhenUnsupported(supportsBlob);
  }

  let products;
  try {
    products = await Product.findAll(options);
  } catch (error) {
    if (supportsBlob && isMissingColumnError(error)) {
      console.warn("Falling back to URL-only product images due to missing columns.");
      products = await Product.findAll({
        ...options,
        attributes: excludeImageColumnsWhenUnsupported(false)
      });
    } else if (isMissingTableError(error)) {
      console.warn("Products table not found; returning empty list to customer.");
      products = [];
    } else {
      throw error;
    }
  }

  return products.map((product) => {
    const mapped = mapProductImage(product);
    mapped.options = Array.isArray(mapped.options) ? mapped.options : [];
    return mapped;
  });
};

const listNews = async ({ limit, search } = {}) => {
  const supportsBlob = (await ensureNewsImageColumns()) !== false;
  const query = {
    order: [["created_at", "DESC"]],
    paranoid: false
  };

  const normalizedSearch = typeof search === "string" ? search.trim() : "";
  if (normalizedSearch) {
    const escaped = normalizedSearch.replace(/[%_\\]/g, "\\$&");
    const pattern = `%${escaped}%`;
    query.where = {
      [Op.or]: [{ title: { [Op.like]: pattern } }, { content: { [Op.like]: pattern } }]
    };
  }

  if (limit) {
    const parsedLimit = Number(limit);
    if (!Number.isNaN(parsedLimit) && parsedLimit > 0) {
      query.limit = Math.min(parsedLimit, 20);
    }
  }

  if (!supportsBlob) {
    query.attributes = excludeImageColumnsWhenUnsupported(supportsBlob);
  }

  let items;
  try {
    items = await News.findAll(query);
  } catch (error) {
    if (supportsBlob && isMissingColumnError(error)) {
      console.warn("Falling back to URL-only news images for customer API due to missing columns.");
      items = await News.findAll({
        ...query,
        attributes: excludeImageColumnsWhenUnsupported(false)
      });
    } else if (isMissingTableError(error)) {
      console.warn("News table not found; returning empty list to customer.");
      items = [];
    } else {
      console.error("Customer listNews error:", error);
      return [];
    }
  }

  return items.map((item) => {
    const plain = item.get({ plain: true });
    return mapImageFields(plain, { includeMime: supportsBlob });
  });
};

const mapOrderPlain = (order) => {
  const plain = order.get({ plain: true });
  const items = Array.isArray(plain.OrderItems) ? plain.OrderItems : [];
  return {
    ...plain,
    items: items.map((item) => ({
      order_item_id: item.order_item_id,
      product_id: item.product_id,
      quantity: item.quantity,
      price: item.price,
      product: item.Product ? mapProductImage(item.Product) : null
    }))
  };
};

const buildOrderSummary = (ordersByStatus, totalSpentRaw) => {
  const summaryMap = ordersByStatus.reduce((acc, item) => {
    acc[item.status] = Number(item.count || 0);
    return acc;
  }, {});

  const totalOrders = ordersByStatus.reduce((sum, item) => sum + Number(item.count || 0), 0);
  const completedOrders = summaryMap.completed || 0;
  const activeOrders = (summaryMap.pending || 0) + (summaryMap.confirmed || 0) + (summaryMap.preparing || 0) + (summaryMap.delivering || 0) + (summaryMap.shipping || 0);
  const canceledOrders = summaryMap.canceled || 0;
  const totalSpent = Number(totalSpentRaw || 0);
  const averageOrderValue = totalOrders ? Number((totalSpent / totalOrders).toFixed(0)) : 0;

  return {
    totalOrders,
    completedOrders,
    activeOrders,
    canceledOrders,
    totalSpent,
    averageOrderValue
  };
};

const getCustomerDashboard = async (userId) => {
  const supportsBlob = (await ensureProductImageColumns()) !== false;
  const productImageAttributes = resolveProductImageAttributes(supportsBlob);
  let profile = null;
  let ordersByStatus = [];
  let totalSpent = 0;
  let recentOrders = [];

  if (userId) {
    const user = await ensureCustomerUser(userId);
    profile = toPlain(user);

    [ordersByStatus, totalSpent, recentOrders] = await Promise.all([
      Order.findAll({
        where: { user_id: userId },
        attributes: ["status", [fn("COUNT", col("status")), "count"]],
        group: ["status"],
        raw: true
      }),
      Order.sum("total_amount", {
        where: {
          user_id: userId,
          status: { [Op.notIn]: ["canceled", "refunded"] }
        }
      }),
      Order.findAll({
        where: { user_id: userId },
        include: [
          {
            model: OrderItem,
            include: [{ model: Product, attributes: productImageAttributes }]
          }
        ],
        order: [["created_at", "DESC"]],
        limit: 5
      })
    ]);

    recentOrders = recentOrders.map(mapOrderPlain);
  }

  const now = new Date();

  const [activePromotions, topProducts] = await Promise.all([
    Promotion.findAll({
      where: {
        is_active: true,
        start_date: { [Op.lte]: now },
        end_date: { [Op.gte]: now },
        [Op.or]: [
          { applicable_roles: null },
          literal("JSON_CONTAINS(COALESCE(applicable_roles, '[]'), '\"customer\"')")
        ]
      },
      order: [["end_date", "ASC"]],
      limit: 5
    }),
    OrderItem.findAll({
      attributes: [
        "product_id",
        [fn("SUM", col("quantity")), "totalSold"],
        [literal("SUM(`OrderItem`.`quantity` * `OrderItem`.`price`)"), "revenue"]
      ],
      include: [
        {
          model: Product,
          attributes: productImageAttributes
        }
      ],
      group: ["product_id", "Product.product_id"],
      order: [[literal("totalSold"), "DESC"]],
      limit: 6
    })
  ]);

  const formattedTopProducts = topProducts.map((item) => ({
    product_id: item.product_id,
    totalSold: Number(item.get("totalSold") || 0),
    revenue: Number(item.get("revenue") || 0),
    product: item.Product ? mapProductImage(item.Product) : null
  }));

  return {
    profile,
    orderSummary: buildOrderSummary(ordersByStatus, totalSpent),
    recentOrders,
    activePromotions: activePromotions.map(toPlain),
    recommendations: formattedTopProducts
  };
};

const listOrdersForCustomer = async (userId, { status } = {}) => {
  await ensureCustomerUser(userId);
  const supportsBlob = (await ensureProductImageColumns()) !== false;
  const productImageAttributes = resolveProductImageAttributes(supportsBlob);
  const where = { user_id: userId };
  if (status && status !== "all") {
    where.status = status;
  }

  let orders;
  try {
    orders = await Order.findAll({
      where,
      include: [
        {
          model: OrderItem,
          include: [{ model: Product, attributes: productImageAttributes }]
        }
      ],
      order: [["created_at", "DESC"]]
    });
  } catch (error) {
    if (isMissingTableError(error)) {
      console.warn("Orders table not found; returning empty list to customer.");
      return [];
    }
    throw error;
  }

  return orders.map(mapOrderPlain);
};

const getCustomerOrder = async (userId, orderId) => {
  await ensureCustomerUser(userId);
  const supportsBlob = (await ensureProductImageColumns()) !== false;
  const productImageAttributes = resolveProductImageAttributes(supportsBlob);
  let order;
  try {
    order = await Order.findOne({
      where: { order_id: orderId, user_id: userId },
      include: [
        {
          model: OrderItem,
          include: [{ model: Product, attributes: productImageAttributes }]
        }
      ]
    });
  } catch (error) {
    if (isMissingTableError(error)) {
      throw new CustomerServiceError("Khong co du lieu don hang trong he thong", 404, "ORDER_TABLE_MISSING");
    }
    throw error;
  }
  if (!order) {
    throw new CustomerServiceError("Khong tim thay don hang", 404, "ORDER_NOT_FOUND");
  }
  return mapOrderPlain(order);
};

const createOrderForCustomer = async (userId, payload = {}) => {
  const items = Array.isArray(payload.items) ? payload.items : [];
  if (!items.length) {
    throw new CustomerServiceError("Don hang phai co it nhat mot san pham", 422, "ORDER_ITEMS_REQUIRED");
  }

  const sanitizedItems = items.map((item, index) => {
    const productId = Number(item.productId ?? item.product_id);
    const quantity = Number(item.quantity);
    if (!productId || Number.isNaN(productId)) {
      throw new CustomerServiceError(`Ma san pham khong hop le tai vi tri ${index + 1}`, 422, "PRODUCT_INVALID");
    }
    if (!quantity || Number.isNaN(quantity) || quantity <= 0) {
      throw new CustomerServiceError(`So luong phai lon hon 0 tai vi tri ${index + 1}`, 422, "QUANTITY_INVALID");
    }
    return { productId, quantity };
  });

  const productIds = [...new Set(sanitizedItems.map((item) => item.productId))];
  const supportsBlob = (await ensureProductImageColumns()) !== false;
  const productImageAttributes = resolveProductImageAttributes(supportsBlob);
  let products;
  try {
    products = await Product.findAll({
      where: { product_id: productIds, is_active: true },
      attributes: supportsBlob ? undefined : excludeImageColumnsWhenUnsupported(supportsBlob)
    });
  } catch (error) {
    if (isMissingTableError(error)) {
      throw new CustomerServiceError("He thong chua khoi tao du lieu san pham", 500, "PRODUCT_TABLE_MISSING");
    }
    throw error;
  }

  if (products.length !== productIds.length) {
    const missing = productIds.filter((id) => !products.some((product) => product.product_id === id));
    throw new CustomerServiceError("Mot so san pham khong ton tai hoac da ngung ban", 404, "PRODUCT_NOT_FOUND", { missing });
  }

  const productMap = products.reduce((acc, product) => {
    acc[product.product_id] = product;
    return acc;
  }, {});

  const orderItemsPayload = sanitizedItems.map((item) => {
    const product = productMap[item.productId];
    return {
      product_id: product.product_id,
      quantity: item.quantity,
      price: Number(product.price)
    };
  });

  const totalAmount = orderItemsPayload.reduce((sum, item) => sum + Number(item.price) * item.quantity, 0);

  return sequelize.transaction(async (transaction) => {
    const order = await Order.create(
      {
        user_id: userId,
        total_amount: totalAmount,
        status: "pending",
        note: payload.note ? String(payload.note).trim() : null,
        expected_delivery_time: payload.expectedDeliveryTime ? new Date(payload.expectedDeliveryTime) : null
      },
      { transaction }
    );

    await OrderItem.bulkCreate(
      orderItemsPayload.map((item) => ({
        ...item,
        order_id: order.order_id
      })),
      { transaction }
    );

    const created = await Order.findByPk(order.order_id, {
      include: [
        {
          model: OrderItem,
          include: [{ model: Product, attributes: productImageAttributes }]
        }
      ],
      transaction
    });

    return mapOrderPlain(created);
  });
};

const cancelCustomerOrder = async (userId, orderId) => {
  await ensureCustomerUser(userId);
  const order = await Order.findOne({ where: { order_id: orderId, user_id: userId } });
  if (!order) {
    throw new CustomerServiceError("Khong tim thay don hang", 404, "ORDER_NOT_FOUND");
  }

  if (["completed", "canceled", "refunded"].includes(order.status)) {
    throw new CustomerServiceError("Don hang khong the huy o trang thai hien tai", 409, "ORDER_NOT_CANCELABLE", {
      status: order.status
    });
  }

  order.status = "canceled";
  await order.save();

  return mapOrderPlain(order);
};

const getProfile = async (userId) => {
  const user = await ensureCustomerUser(userId);
  return toPlain(user);
};

const createProfile = async (userId, payload = {}) => {
  const user = await ensureCustomerUser(userId);
  if (profileHasStoredDetails(user)) {
    throw new CustomerServiceError(
      "Thong tin nguoi dung da ton tai. Vui long su dung chuc nang cap nhat.",
      409,
      "PROFILE_ALREADY_EXISTS"
    );
  }

  const updates = sanitizeProfileFields(payload);
  if (!Object.keys(updates).length || !hasMeaningfulProfileValue(updates)) {
    throw new CustomerServiceError(
      "Vui long cung cap it nhat mot truong thong tin.",
      422,
      "PROFILE_MISSING_FIELDS"
    );
  }

  if (!Object.prototype.hasOwnProperty.call(updates, "gender")) {
    updates.gender = "unknown";
  }

  await user.update({
    full_name: null,
    phone_number: null,
    address: null,
    gender: "unknown",
    ...updates
  });

  return toPlain(user);
};

const updateProfile = async (userId, payload = {}) => {
  const user = await ensureCustomerUser(userId);
  const updates = sanitizeProfileFields(payload);

  if (!Object.keys(updates).length) {
    throw new CustomerServiceError("Khong co truong nao duoc cap nhat", 422, "NO_UPDATES");
  }

  await user.update(updates);
  return toPlain(user);
};

const deleteProfile = async (userId) => {
  const user = await ensureCustomerUser(userId);
  await user.update({
    full_name: null,
    phone_number: null,
    address: null,
    gender: "unknown"
  });
  return toPlain(user);
};

// ========================= Cart =========================
const getOrCreateCart = async (userId) => {
  await ensureCustomerUser(userId);
  let cart = await Cart.findOne({ where: { user_id: userId } });
  if (!cart) {
    cart = await Cart.create({ user_id: userId });
  }
  return cart;
};

const listCart = async (userId) => {
  const cart = await getOrCreateCart(userId);
  const items = await CartItem.findAll({
    where: { cart_id: cart.cart_id },
    include: [{ model: Product }],
    order: [["updated_at", "DESC"]]
  });

  const mapped = items.map((row) => {
    const plain = row.get({ plain: true });
    const product = plain.Product ? mapProductImage(plain.Product) : null;
    const price = Number(product?.price || 0);
    const qty = Number(plain.quantity || 1);
    return {
      cart_item_id: plain.cart_item_id,
      product_id: plain.product_id,
      quantity: qty,
      price,
      subtotal: Math.round(price * qty * 100) / 100,
      product
    };
  });

  const subtotal = mapped.reduce((sum, it) => sum + (Number(it.price) || 0) * (Number(it.quantity) || 1), 0);
  const total_items = mapped.reduce((sum, it) => sum + (Number(it.quantity) || 1), 0);

  return { items: mapped, subtotal, total_items };
};

const addItemToCart = async (userId, { productId, quantity } = {}) => {
  const product = await Product.findByPk(productId);
  if (!product) {
    throw new CustomerServiceError("Khong tim thay mon an", 404, "PRODUCT_NOT_FOUND");
  }
  const cart = await getOrCreateCart(userId);
  const qty = Math.max(1, Number(quantity) || 1);
  const [item, created] = await CartItem.findOrCreate({
    where: { cart_id: cart.cart_id, product_id: product.product_id },
    defaults: { quantity: qty }
  });
  if (!created) {
    await item.update({ quantity: (Number(item.quantity) || 0) + qty });
  }
  return listCart(userId);
};

const updateCartItemQuantity = async (userId, productId, quantity) => {
  const cart = await getOrCreateCart(userId);
  const item = await CartItem.findOne({ where: { cart_id: cart.cart_id, product_id: productId } });
  if (!item) {
    throw new CustomerServiceError("Mon an khong co trong gio", 404, "CART_ITEM_NOT_FOUND");
  }
  const qty = Math.max(0, Number(quantity) || 0);
  if (qty <= 0) {
    await item.destroy();
    return listCart(userId);
  }
  await item.update({ quantity: qty });
  return listCart(userId);
};

const removeCartItem = async (userId, productId) => {
  const cart = await getOrCreateCart(userId);
  await CartItem.destroy({ where: { cart_id: cart.cart_id, product_id: productId } });
  return listCart(userId);
};

const clearCart = async (userId) => {
  const cart = await getOrCreateCart(userId);
  await CartItem.destroy({ where: { cart_id: cart.cart_id } });
  return listCart(userId);
};

// ========================= Support =========================
const listMySupportMessages = async (userId) => {
  await ensureCustomerUser(userId);
  const items = await Message.findAll({
    where: { user_id: userId },
    include: [{ model: User, attributes: ["user_id", "username", "full_name"] }],
    order: [["created_at", "ASC"]],
    paranoid: false
  });
  return items.map((row) => row.get({ plain: true }));
};

const createSupportMessage = async (userId, content) => {
  const user = await ensureCustomerUser(userId);
  const text = String(content || '').trim();

  const row = await Message.create({
    user_id: user.user_id,
    message: text,
    from_role: 'user',
    channel: 'web',
    sent_at: new Date()
  });

  // Link to conversation + create chat message for multi-turn support
  let convo = null; try { convo = await findOrCreateConversation(user.user_id); } catch (error) { if (!isMissingTableError(error)) { throw error; } }
  if (convo) { try { await ChatMessage.create({ conversation_id: convo.conversation_id, sender_role: 'user', body: text }); if (convo) { try { await convo.update({ last_message_at: new Date() }); } catch {} } } catch (error) { if (!isMissingTableError(error)) { throw error; } } }
  if (convo) { try { await convo.update({ last_message_at: new Date() }); } catch {} }

  // Try auto-reply
  const auto = generateAutoReply(text);
  if (auto) {
    await row.update({ reply: auto, from_role: 'bot' });
    if (convo) { try { await ChatMessage.create({ conversation_id: convo.conversation_id, sender_role: 'bot', body: auto }); await convo.update({ last_message_at: new Date() }); } catch (error) { if (!isMissingTableError(error)) { throw error; } } }
    if (convo) { try { await convo.update({ last_message_at: new Date() }); } catch {} }
  }

  // attach minimal user info for convenience
  const plain = row.get({ plain: true });
  plain.User = { user_id: user.user_id, username: user.username, full_name: user.full_name };
  return plain;
};

// ===== Conversation helpers =====
const findOrCreateConversation = async (userId) => {
  let convo = await Conversation.findOne({ where: { user_id: userId, status: 'open' }, order: [["updated_at", "DESC"]] });
  if (!convo) {
    convo = await Conversation.create({ user_id: userId, status: 'open', last_message_at: new Date() });
  }
  return convo;
};

const listMyConversationMessages = async (userId, { limit = 200 } = {}) => {
  await ensureCustomerUser(userId);
  let convo = null; try { convo = await findOrCreateConversation(userId); } catch (error) { if (!isMissingTableError(error)) { throw error; } }
  let items; if (convo) { try { items = await ChatMessage.findAll({ where: { conversation_id: convo.conversation_id }, order: [["created_at", "ASC"]], limit: Math.min(Number(limit) || 200, 500) }); } catch (error) { if (!isMissingTableError(error)) { throw error; } } } if (!items) { const legacy = await Message.findAll({ where: { user_id: userId }, order: [["created_at","ASC"]], paranoid: false }); items = legacy.flatMap((m) => { const list = [{ chat_message_id: m.message_id * 2 - 1, conversation_id: 0, sender_role: "user", body: m.message, created_at: m.created_at, updated_at: m.updated_at }]; if (m.reply) { list.push({ chat_message_id: m.message_id * 2, conversation_id: 0, sender_role: "staff", body: m.reply, created_at: m.updated_at, updated_at: m.updated_at }); } return list; }); }
  return items.map((r) => r.get({ plain: true }));
};

const appendMyConversationMessage = async (userId, content) => {
  await ensureCustomerUser(userId);
  let convo = null; try { convo = await findOrCreateConversation(userId); } catch (error) { if (!isMissingTableError(error)) { throw error; } }
  const body = String(content || '').trim();
  if (!body) return null;
  const chat = let createdUserMsg = null; if (convo) { try { createdUserMsg = await ChatMessage.create({ conversation_id: convo.conversation_id, sender_role: 'user', body }); await convo.update({ last_message_at: new Date() }); } catch (error) { if (!isMissingTableError(error)) { throw error; } } } else { // legacy fallback
await Message.create({ user_id: userId, message: body, from_role: 'user', channel: 'web', sent_at: new Date() }); }
  if (convo) { try { await convo.update({ last_message_at: new Date() }); } catch {} }
  const auto = generateAutoReply(body);
  let bot = null;
  if (auto) {
    bot = if (convo) { try { await ChatMessage.create({ conversation_id: convo.conversation_id, sender_role: 'bot', body: auto }); await convo.update({ last_message_at: new Date() }); } catch (error) { if (!isMissingTableError(error)) { throw error; } } }
    if (convo) { try { await convo.update({ last_message_at: new Date() }); } catch {} }
  }
  return { user: chat.get({ plain: true }), bot: bot ? bot.get({ plain: true }) : null };
};

// ===== Auto-reply engine (simple keyword rules) =====
const normalize = (s) =>
  String(s || '')
    .toLowerCase()
    .normalize('NFD')
    .replace(/[\u0300-\u036f]/g, '');

const containsAny = (s, arr) => {
  const n = normalize(s);
  return arr.some((kw) => n.includes(normalize(kw)));
};

const generateAutoReply = (content) => {
  const c = String(content || '');

  // Working hours
  if (containsAny(c, ['mo cua', 'mo câº€a', 'gio mo', 'gio dong', 'thoi gian lam viec', 'open', 'close'])) {
    return 'Quan mo cua tu 8:00 den 22:00 moi ngay.';
  }

  // Menu
  if (containsAny(c, ['menu', 'thuc don', 'co mon gi', 'goi mon'])) {
    return 'Ban co the xem menu va dat mon tai trang /menu.';
  }

  // Delivery / shipping
  if (containsAny(c, ['giao hang', 'ship', 'shipper', 'phi van chuyen', 'phi ship'])) {
    return 'Chung toi co giao hang qua doi tac. Phi giao hang duoc hien thi o buoc thanh toan tuy khu vuc.';
  }

  // Promotions
  if (containsAny(c, ['khuyen mai', 'ma giam gia', 'voucher', 'uu dai'])) {
    return 'Cac chuong trinh khuyen mai duoc cap nhat tai trang Khuyen Mai. Vui long kiem tra muc News/Promotions.';
  }

  // Payment
  if (containsAny(c, ['thanh toan', 'momo', 'zalo pay', 'zalopay', 'vnpay', 'tien mat'])) {
    return 'Ho tro thanh toan tien mat khi nhan hang va mot so vi dien tu/online tuy khu vuc.';
  }

  // Order status
  if (containsAny(c, ['don hang', 'trang thai don', 'kiem tra don'])) {
    return 'Ban co the xem trang thai don hang trong khu vuc tai khoan > Don hang.';
  }

  // Address / location
  if (containsAny(c, ['dia chi', 'o dau', 'chi nhanh'])) {
    return 'Hien chung toi phuc vu online va takeaway trong khung gio 8:00-22:00. Thong tin chi nhanh se duoc cap nhat tren trang chu.';
  }

  // Fallback
  if (c.length >= 4) {
    return 'Cam on ban da lien he! Nhan vien se ho tro ban som nhat.';
  }
  return null;
};

export {
  CustomerServiceError,
  listActiveProducts,
  listNews,
  getCustomerDashboard,
  listOrdersForCustomer,
  getCustomerOrder,
  createOrderForCustomer,
  cancelCustomerOrder,
  getProfile,
  createProfile,
  updateProfile,
  deleteProfile,
  // support
  listMySupportMessages,
  createSupportMessage,
  listMyConversationMessages,
  appendMyConversationMessage,
  // cart
  listCart,
  addItemToCart,
  updateCartItemQuantity,
  removeCartItem,
  clearCart
};




