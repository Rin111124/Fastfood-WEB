"use strict";

import { Op, fn, col, literal } from "sequelize";
import db from "../../models/index.js";
import { ensureProductImageColumns, ensureNewsImageColumns } from "../../utils/schemaEnsurer.js";
import { mapImageFields } from "../../utils/imageMapper.js";
import { isMissingColumnError, isMissingTableError } from "../../utils/dbErrors.js";

const {
  sequelize,
  User,
  Order,
  OrderItem,
  Product,
  Promotion,
  News,
  Cart,
  CartItem,
  Message,
  Conversation,
  ChatMessage
} = db;

class CustomerServiceError extends Error {
  constructor(message, statusCode = 400, code = "CUSTOMER_SERVICE_ERROR", metadata = {}) {
    super(message);
    this.name = "CustomerServiceError";
    this.statusCode = statusCode;
    this.code = code;
    this.metadata = metadata;
  }
}

const toPlain = (item) => (item?.get ? item.get({ plain: true }) : item);

const mapProductImage = (product) => {
  if (!product) return product;
  const plain = product?.get ? product.get({ plain: true }) : product;
  return mapImageFields(plain);
};

const resolveProductImageAttributes = (supportsBlob) => {
  const attrs = ["product_id", "name", "price", "image_url", "food_type"];
  if (supportsBlob) {
    attrs.splice(3, 0, "image_data", "image_mime");
  }
  return attrs;
};

const excludeImageColumnsWhenUnsupported = (supportsBlob) =>
  supportsBlob ? undefined : { exclude: ["image_data", "image_mime"] };

const ensureCustomerUser = async (userId) => {
  const user = await User.findByPk(userId);
  if (!user) {
    throw new CustomerServiceError("Khong tim thay nguoi dung", 404, "USER_NOT_FOUND");
  }
  if (!["customer", "admin"].includes(user.role)) {
    throw new CustomerServiceError("Vai tro khong duoc phep thuc hien thao tac nay", 403, "ROLE_NOT_ALLOWED");
  }
  return user;
};

const PROFILE_FIELDS = ["full_name", "phone_number", "address", "gender"];
const VALID_GENDERS = new Set(["male", "female", "other", "unknown"]);

const sanitizeProfileFields = (payload = {}) => {
  const result = {};
  PROFILE_FIELDS.forEach((field) => {
    if (!Object.prototype.hasOwnProperty.call(payload, field)) {
      return;
    }
    const value = payload[field];
    if (field === "gender") {
      if (value === null || value === undefined) {
        result[field] = "unknown";
        return;
      }
      const normalized = typeof value === "string" ? value.trim().toLowerCase() : value;
      result[field] = VALID_GENDERS.has(normalized) ? normalized : "unknown";
      return;
    }
    if (value === null || value === undefined) {
      result[field] = null;
      return;
    }
    if (typeof value === "string") {
      const trimmed = value.trim();
      result[field] = trimmed.length ? trimmed : null;
      return;
    }
    result[field] = value;
  });
  return result;
};

const hasMeaningfulProfileValue = (payload = {}) =>
  PROFILE_FIELDS.some((field) => {
    if (!Object.prototype.hasOwnProperty.call(payload, field)) {
      return false;
    }
    const value = payload[field];
    if (field === "gender") {
      return Boolean(value) && value !== "unknown";
    }
    if (value === null || value === undefined) {
      return false;
    }
    if (typeof value === "string") {
      return value.trim().length > 0;
    }
    return true;
  });

const profileHasStoredDetails = (user) =>
  Boolean(
    user?.full_name ||
      user?.phone_number ||
      user?.address ||
      (user?.gender && user.gender !== "unknown")
  );

const listActiveProducts = async ({ search, categoryId, limit } = {}) => {
  const supportsBlob = (await ensureProductImageColumns()) !== false;
  const where = {};
  if (categoryId) {
    where.category_id = Number(categoryId);
  }
  if (search) {
    where.name = { [Op.like]: `%${search.trim()}%` };
  }

  const options = {
    where,
    include: [{ model: db.ProductOption, as: "options" }],
    order: [["updated_at", "DESC"]]
  };

  if (limit) {
    const parsedLimit = Number(limit);
    if (!Number.isNaN(parsedLimit) && parsedLimit > 0) {
      options.limit = Math.min(parsedLimit, 50);
    }
  }

  if (!supportsBlob) {
    options.attributes = excludeImageColumnsWhenUnsupported(supportsBlob);
  }

  let products;
  try {
    products = await Product.findAll(options);
  } catch (error) {
    if (supportsBlob && isMissingColumnError(error)) {
      console.warn("Falling back to URL-only product images due to missing columns.");
      products = await Product.findAll({
        ...options,
        attributes: excludeImageColumnsWhenUnsupported(false)
      });
    } else if (isMissingTableError(error)) {
      console.warn("Products table not found; returning empty list to customer.");
      products = [];
    } else {
      throw error;
    }
  }

  return products.map((product) => {
    const mapped = mapProductImage(product);
    mapped.options = Array.isArray(mapped.options) ? mapped.options : [];
    return mapped;
  });
};

const listNews = async ({ limit, search } = {}) => {
  const supportsBlob = (await ensureNewsImageColumns()) !== false;
  const query = {
    order: [["created_at", "DESC"]],
    paranoid: false
  };

  const normalizedSearch = typeof search === "string" ? search.trim() : "";
  if (normalizedSearch) {
    const escaped = normalizedSearch.replace(/[%_\\]/g, "\\$&");
    const pattern = `%${escaped}%`;
    query.where = {
      [Op.or]: [{ title: { [Op.like]: pattern } }, { content: { [Op.like]: pattern } }]
    };
  }

  if (limit) {
    const parsedLimit = Number(limit);
    if (!Number.isNaN(parsedLimit) && parsedLimit > 0) {
      query.limit = Math.min(parsedLimit, 20);
    }
  }

  if (!supportsBlob) {
    query.attributes = excludeImageColumnsWhenUnsupported(supportsBlob);
  }

  let items;
  try {
    items = await News.findAll(query);
  } catch (error) {
    if (supportsBlob && isMissingColumnError(error)) {
      console.warn("Falling back to URL-only news images for customer API due to missing columns.");
      items = await News.findAll({
        ...query,
        attributes: excludeImageColumnsWhenUnsupported(false)
      });
    } else if (isMissingTableError(error)) {
      console.warn("News table not found; returning empty list to customer.");
      items = [];
    } else {
      console.error("Customer listNews error:", error);
      return [];
    }
  }

  return items.map((item) => {
    const plain = item.get({ plain: true });
    return mapImageFields(plain, { includeMime: supportsBlob });
  });
};

const mapOrderPlain = (order) => {
  const plain = order.get({ plain: true });
  const items = Array.isArray(plain.OrderItems) ? plain.OrderItems : [];
  return {
    ...plain,
    items: items.map((item) => ({
      order_item_id: item.order_item_id,
      product_id: item.product_id,
      quantity: item.quantity,
      price: item.price,
      product: item.Product ? mapProductImage(item.Product) : null
    }))
  };
};

const buildOrderSummary = (ordersByStatus, totalSpentRaw) => {
  const summaryMap = ordersByStatus.reduce((acc, item) => {
    acc[item.status] = Number(item.count || 0);
    return acc;
  }, {});

  const totalOrders = ordersByStatus.reduce((sum, item) => sum + Number(item.count || 0), 0);
  const completedOrders = summaryMap.completed || 0;
  const activeOrders = (summaryMap.pending || 0) + (summaryMap.confirmed || 0) + (summaryMap.preparing || 0) + (summaryMap.delivering || 0) + (summaryMap.shipping || 0);
  const canceledOrders = summaryMap.canceled || 0;
  const totalSpent = Number(totalSpentRaw || 0);
  const averageOrderValue = totalOrders ? Number((totalSpent / totalOrders).toFixed(0)) : 0;

  return {
    totalOrders,
    completedOrders,
    activeOrders,
    canceledOrders,
    totalSpent,
    averageOrderValue
  };
};

const getCustomerDashboard = async (userId) => {
  const supportsBlob = (await ensureProductImageColumns()) !== false;
  const productImageAttributes = resolveProductImageAttributes(supportsBlob);
  let profile = null;
  let ordersByStatus = [];
  let totalSpent = 0;
  let recentOrders = [];

  if (userId) {
    const user = await ensureCustomerUser(userId);
    profile = toPlain(user);

    [ordersByStatus, totalSpent, recentOrders] = await Promise.all([
      Order.findAll({
        where: { user_id: userId },
        attributes: ["status", [fn("COUNT", col("status")), "count"]],
        group: ["status"],
        raw: true
      }),
      Order.sum("total_amount", {
        where: {
          user_id: userId,
          status: { [Op.notIn]: ["canceled", "refunded"] }
        }
      }),
      Order.findAll({
        where: { user_id: userId },
        include: [
          {
            model: OrderItem,
            include: [{ model: Product, attributes: productImageAttributes }]
          }
        ],
        order: [["created_at", "DESC"]],
        limit: 5
      })
    ]);

    recentOrders = recentOrders.map(mapOrderPlain);
  }

  const now = new Date();

  const [activePromotions, topProducts] = await Promise.all([
    Promotion.findAll({
      where: {
        is_active: true,
        start_date: { [Op.lte]: now },
        end_date: { [Op.gte]: now },
        [Op.or]: [
          { applicable_roles: null },
          literal("JSON_CONTAINS(COALESCE(applicable_roles, '[]'), '\"customer\"')")
        ]
      },
      order: [["end_date", "ASC"]],
      limit: 5
    }),
    OrderItem.findAll({
      attributes: [
        "product_id",
        [fn("SUM", col("quantity")), "totalSold"],
        [literal("SUM(`OrderItem`.`quantity` * `OrderItem`.`price`)"), "revenue"]
      ],
      include: [
        {
          model: Product,
          attributes: productImageAttributes
        }
      ],
      group: ["product_id", "Product.product_id"],
      order: [[literal("totalSold"), "DESC"]],
      limit: 6
    })
  ]);

  const formattedTopProducts = topProducts.map((item) => ({
    product_id: item.product_id,
    totalSold: Number(item.get("totalSold") || 0),
    revenue: Number(item.get("revenue") || 0),
    product: item.Product ? mapProductImage(item.Product) : null
  }));

  return {
    profile,
    orderSummary: buildOrderSummary(ordersByStatus, totalSpent),
    recentOrders,
    activePromotions: activePromotions.map(toPlain),
    recommendations: formattedTopProducts
  };
};

const listOrdersForCustomer = async (userId, { status } = {}) => {
  await ensureCustomerUser(userId);
  const supportsBlob = (await ensureProductImageColumns()) !== false;
  const productImageAttributes = resolveProductImageAttributes(supportsBlob);
  const where = { user_id: userId };
  if (status && status !== "all") {
    where.status = status;
  }

  let orders;
  try {
    orders = await Order.findAll({
      where,
      include: [
        {
          model: OrderItem,
          include: [{ model: Product, attributes: productImageAttributes }]
        }
      ],
      order: [["created_at", "DESC"]]
    });
  } catch (error) {
    if (isMissingTableError(error)) {
      console.warn("Orders table not found; returning empty list to customer.");
      return [];
    }
    throw error;
  }

  return orders.map(mapOrderPlain);
};

const getCustomerOrder = async (userId, orderId) => {
  await ensureCustomerUser(userId);
  const supportsBlob = (await ensureProductImageColumns()) !== false;
  const productImageAttributes = resolveProductImageAttributes(supportsBlob);
  let order;
  try {
    order = await Order.findOne({
      where: { order_id: orderId, user_id: userId },
      include: [
        {
          model: OrderItem,
          include: [{ model: Product, attributes: productImageAttributes }]
        }
      ]
    });
  } catch (error) {
    if (isMissingTableError(error)) {
      throw new CustomerServiceError("Khong co du lieu don hang trong he thong", 404, "ORDER_TABLE_MISSING");
    }
    throw error;
  }
  if (!order) {
    throw new CustomerServiceError("Khong tim thay don hang", 404, "ORDER_NOT_FOUND");
  }
  return mapOrderPlain(order);
};

const createOrderForCustomer = async (userId, payload = {}) => {
  const items = Array.isArray(payload.items) ? payload.items : [];
  if (!items.length) {
    throw new CustomerServiceError("Don hang phai co it nhat mot san pham", 422, "ORDER_ITEMS_REQUIRED");
  }

  const sanitizedItems = items.map((item, index) => {
    const productId = Number(item.productId ?? item.product_id);
    const quantity = Number(item.quantity);
    if (!productId || Number.isNaN(productId)) {
      throw new CustomerServiceError(`Ma san pham khong hop le tai vi tri ${index + 1}`, 422, "PRODUCT_INVALID");
    }
    if (!quantity || Number.isNaN(quantity) || quantity <= 0) {
      throw new CustomerServiceError(`So luong phai lon hon 0 tai vi tri ${index + 1}`, 422, "QUANTITY_INVALID");
    }
    return { productId, quantity };
  });

  const productIds = [...new Set(sanitizedItems.map((item) => item.productId))];
  const supportsBlob = (await ensureProductImageColumns()) !== false;
  const productImageAttributes = resolveProductImageAttributes(supportsBlob);
  let products;
  try {
    products = await Product.findAll({
      where: { product_id: productIds, is_active: true },
      attributes: supportsBlob ? undefined : excludeImageColumnsWhenUnsupported(supportsBlob)
    });
  } catch (error) {
    if (isMissingTableError(error)) {
      throw new CustomerServiceError("He thong chua khoi tao du lieu san pham", 500, "PRODUCT_TABLE_MISSING");
    }
    throw error;
  }

  if (products.length !== productIds.length) {
    const missing = productIds.filter((id) => !products.some((product) => product.product_id === id));
    throw new CustomerServiceError("Mot so san pham khong ton tai hoac da ngung ban", 404, "PRODUCT_NOT_FOUND", { missing });
  }

  const productMap = products.reduce((acc, product) => {
    acc[product.product_id] = product;
    return acc;
  }, {});

  const orderItemsPayload = sanitizedItems.map((item) => {
    const product = productMap[item.productId];
    return {
      product_id: product.product_id,
      quantity: item.quantity,
      price: Number(product.price)
    };
  });

  const totalAmount = orderItemsPayload.reduce((sum, item) => sum + Number(item.price) * item.quantity, 0);

  return sequelize.transaction(async (transaction) => {
    const order = await Order.create(
      {
        user_id: userId,
        total_amount: totalAmount,
        status: "pending",
        note: payload.note ? String(payload.note).trim() : null,
        expected_delivery_time: payload.expectedDeliveryTime ? new Date(payload.expectedDeliveryTime) : null
      },
      { transaction }
    );

    await OrderItem.bulkCreate(
      orderItemsPayload.map((item) => ({
        ...item,
        order_id: order.order_id
      })),
      { transaction }
    );

    const created = await Order.findByPk(order.order_id, {
      include: [
        {
          model: OrderItem,
          include: [{ model: Product, attributes: productImageAttributes }]
        }
      ],
      transaction
    });

    return mapOrderPlain(created);
  });
};

const cancelCustomerOrder = async (userId, orderId) => {
  await ensureCustomerUser(userId);
  const order = await Order.findOne({ where: { order_id: orderId, user_id: userId } });
  if (!order) {
    throw new CustomerServiceError("Khong tim thay don hang", 404, "ORDER_NOT_FOUND");
  }

  if (["completed", "canceled", "refunded"].includes(order.status)) {
    throw new CustomerServiceError("Don hang khong the huy o trang thai hien tai", 409, "ORDER_NOT_CANCELABLE", {
      status: order.status
    });
  }

  order.status = "canceled";
  await order.save();

  return mapOrderPlain(order);
};

const getProfile = async (userId) => {
  const user = await ensureCustomerUser(userId);
  return toPlain(user);
};

const createProfile = async (userId, payload = {}) => {
  const user = await ensureCustomerUser(userId);
  if (profileHasStoredDetails(user)) {
    throw new CustomerServiceError(
      "Thong tin nguoi dung da ton tai. Vui long su dung chuc nang cap nhat.",
      409,
      "PROFILE_ALREADY_EXISTS"
    );
  }

  const updates = sanitizeProfileFields(payload);
  if (!Object.keys(updates).length || !hasMeaningfulProfileValue(updates)) {
    throw new CustomerServiceError(
      "Vui long cung cap it nhat mot truong thong tin.",
      422,
      "PROFILE_MISSING_FIELDS"
    );
  }

  if (!Object.prototype.hasOwnProperty.call(updates, "gender")) {
    updates.gender = "unknown";
  }

  await user.update({
    full_name: null,
    phone_number: null,
    address: null,
    gender: "unknown",
    ...updates
  });

  return toPlain(user);
};

const updateProfile = async (userId, payload = {}) => {
  const user = await ensureCustomerUser(userId);
  const updates = sanitizeProfileFields(payload);

  if (!Object.keys(updates).length) {
    throw new CustomerServiceError("Khong co truong nao duoc cap nhat", 422, "NO_UPDATES");
  }

  await user.update(updates);
  return toPlain(user);
};

const deleteProfile = async (userId) => {
  const user = await ensureCustomerUser(userId);
  await user.update({
    full_name: null,
    phone_number: null,
    address: null,
    gender: "unknown"
  });
  return toPlain(user);
};

// ========================= Cart =========================
const getOrCreateCart = async (userId) => {
  await ensureCustomerUser(userId);
  let cart = await Cart.findOne({ where: { user_id: userId } });
  if (!cart) {
    cart = await Cart.create({ user_id: userId });
  }
  return cart;
};

const listCart = async (userId) => {
  const cart = await getOrCreateCart(userId);
  const items = await CartItem.findAll({
    where: { cart_id: cart.cart_id },
    include: [{ model: Product }],
    order: [["updated_at", "DESC"]]
  });

  const mapped = items.map((row) => {
    const plain = row.get({ plain: true });
    const product = plain.Product ? mapProductImage(plain.Product) : null;
    const price = Number(product?.price || 0);
    const qty = Number(plain.quantity || 1);
    return {
      cart_item_id: plain.cart_item_id,
      product_id: plain.product_id,
      quantity: qty,
      price,
      subtotal: Math.round(price * qty * 100) / 100,
      product
    };
  });

  const subtotal = mapped.reduce((sum, it) => sum + (Number(it.price) || 0) * (Number(it.quantity) || 1), 0);
  const total_items = mapped.reduce((sum, it) => sum + (Number(it.quantity) || 1), 0);

  return { items: mapped, subtotal, total_items };
};

const addItemToCart = async (userId, { productId, quantity } = {}) => {
  const product = await Product.findByPk(productId);
  if (!product) {
    throw new CustomerServiceError("Khong tim thay mon an", 404, "PRODUCT_NOT_FOUND");
  }
  const cart = await getOrCreateCart(userId);
  const qty = Math.max(1, Number(quantity) || 1);
  const [item, created] = await CartItem.findOrCreate({
    where: { cart_id: cart.cart_id, product_id: product.product_id },
    defaults: { quantity: qty }
  });
  if (!created) {
    await item.update({ quantity: (Number(item.quantity) || 0) + qty });
  }
  return listCart(userId);
};

const updateCartItemQuantity = async (userId, productId, quantity) => {
  const cart = await getOrCreateCart(userId);
  const item = await CartItem.findOne({ where: { cart_id: cart.cart_id, product_id: productId } });
  if (!item) {
    throw new CustomerServiceError("Mon an khong co trong gio", 404, "CART_ITEM_NOT_FOUND");
  }
  const qty = Math.max(0, Number(quantity) || 0);
  if (qty <= 0) {
    await item.destroy();
    return listCart(userId);
  }
  await item.update({ quantity: qty });
  return listCart(userId);
};

const removeCartItem = async (userId, productId) => {
  const cart = await getOrCreateCart(userId);
  await CartItem.destroy({ where: { cart_id: cart.cart_id, product_id: productId } });
  return listCart(userId);
};

const clearCart = async (userId) => {
  const cart = await getOrCreateCart(userId);
  await CartItem.destroy({ where: { cart_id: cart.cart_id } });
  return listCart(userId);
};

// ========================= Support =========================
const listMySupportMessages = async (userId) => {
  await ensureCustomerUser(userId);
  const items = await Message.findAll({
    where: { user_id: userId },
    include: [{ model: User, attributes: ["user_id", "username", "full_name"] }],
    order: [["created_at", "ASC"]],
    paranoid: false
  });
  return items.map((row) => row.get({ plain: true }));
};

const createSupportMessage = async (userId, content) => {
  const user = await ensureCustomerUser(userId);
  const text = String(content || '').trim();

  const row = await Message.create({
    user_id: user.user_id,
    message: text,
    from_role: 'user',
    channel: 'web',
    sent_at: new Date()
  });

  // Link to conversation + create chat message for multi-turn support
  let convo = null; try { convo = await findOrCreateConversation(user.user_id); } catch (error) { if (!isMissingTableError(error)) { throw error; } }
  if (convo) { try { await ChatMessage.create({ conversation_id: convo.conversation_id, sender_role: 'user', body: text }); if (convo) { try { await convo.update({ last_message_at: new Date() }); } catch {} } } catch (error) { if (!isMissingTableError(error)) { throw error; } } }
  if (convo) { try { await convo.update({ last_message_at: new Date() }); } catch {} }

  // Try auto-reply
  const auto = await generateSmartReply(user.user_id, text);
  if (auto) {
    await row.update({ reply: auto, from_role: 'bot' });
    if (convo) { try { await ChatMessage.create({ conversation_id: convo.conversation_id, sender_role: 'bot', body: auto }); await convo.update({ last_message_at: new Date() }); } catch (error) { if (!isMissingTableError(error)) { throw error; } } }
    if (convo) { try { await convo.update({ last_message_at: new Date() }); } catch {} }
  }

  // attach minimal user info for convenience
  const plain = row.get({ plain: true });
  plain.User = { user_id: user.user_id, username: user.username, full_name: user.full_name };
  return plain;
};

// ===== Conversation helpers =====
const findOrCreateConversation = async (userId) => {
  let convo = await Conversation.findOne({ where: { user_id: userId, status: 'open' }, order: [["updated_at", "DESC"]] });
  if (!convo) {
    convo = await Conversation.create({ user_id: userId, status: 'open', last_message_at: new Date() });
  }
  return convo;
};

const listMyConversationMessages = async (userId, { limit = 200 } = {}) => {
  await ensureCustomerUser(userId);
  let convo = null; try { convo = await findOrCreateConversation(userId); } catch (error) { if (!isMissingTableError(error)) { throw error; } }
  let items; if (convo) { try { items = await ChatMessage.findAll({ where: { conversation_id: convo.conversation_id }, order: [["created_at", "ASC"]], limit: Math.min(Number(limit) || 200, 500) }); } catch (error) { if (!isMissingTableError(error)) { throw error; } } } if (!items) { const legacy = await Message.findAll({ where: { user_id: userId }, order: [["created_at","ASC"]], paranoid: false }); items = legacy.flatMap((m) => { const list = [{ chat_message_id: m.message_id * 2 - 1, conversation_id: 0, sender_role: "user", body: m.message, created_at: m.created_at, updated_at: m.updated_at }]; if (m.reply) { list.push({ chat_message_id: m.message_id * 2, conversation_id: 0, sender_role: "staff", body: m.reply, created_at: m.updated_at, updated_at: m.updated_at }); } return list; }); }
  return items.map((r) => r.get({ plain: true }));
};

const appendMyConversationMessage = async (userId, content) => {
  await ensureCustomerUser(userId);
  let convo = null; try { convo = await findOrCreateConversation(userId); } catch (error) { if (!isMissingTableError(error)) { throw error; } }
  const body = String(content || '').trim();
  if (!body) return null;
  const chat = let createdUserMsg = null; if (convo) { try { createdUserMsg = await ChatMessage.create({ conversation_id: convo.conversation_id, sender_role: 'user', body }); await convo.update({ last_message_at: new Date() }); } catch (error) { if (!isMissingTableError(error)) { throw error; } } } else { // legacy fallback
await Message.create({ user_id: userId, message: body, from_role: 'user', channel: 'web', sent_at: new Date() }); }
  if (convo) { try { await convo.update({ last_message_at: new Date() }); } catch {} }
  const auto = await generateSmartReply(userId, body);
  let bot = null;
  if (auto) {
    bot = if (convo) { try { await ChatMessage.create({ conversation_id: convo.conversation_id, sender_role: 'bot', body: auto }); await convo.update({ last_message_at: new Date() }); } catch (error) { if (!isMissingTableError(error)) { throw error; } } }
    if (convo) { try { await convo.update({ last_message_at: new Date() }); } catch {} }
  }
  return { user: chat.get({ plain: true }), bot: bot ? bot.get({ plain: true }) : null };
};

// ===== Auto-reply engine (smart rules) =====
const normalize = (s) =>
  String(s || '')
    .toLowerCase()
    .normalize('NFD')
    .replace(/[\u0300-\u036f]/g, '');

const containsAny = (s, arr) => {
  const n = normalize(s);
  return arr.some((kw) => n.includes(normalize(kw)));
};

const isPhoneLike = (s) => /0\d{9,10}/.test(String(s || ''));
const isOrderCodeLike = (s) => /#?\d{4,8}/.test(String(s || ''));

const greetText = (brand = 'FatFood', botName = 'FatBot') =>
  `Chao ban! ðŸ‘‹ Toi la ${botName}, tro ly toc do cua ${brand}!

Toi co the giup ban:
ðŸ• Xem thuc don & mon moi
ðŸ›µ Kiem tra tinh trang don hang
ðŸŽ Tim khuyen mai hom nay

Ban chi can go yeu cau va nhan gui, toi se tra loi ngay! Ban can ho tro gi a?`;

const buildOrderStatusText = (status) => {
  switch (String(status || '').toLowerCase()) {
    case 'preparing':
    case 'confirmed':
      return 'ðŸ³ Trang thai: Don hang dang duoc chuan bi trong bep. â° Du kien giao: 25-30 phut tiep theo.';
    case 'delivering':
    case 'shipping':
      return 'ðŸ›µ Trang thai: Don hang dang tren duong giao den ban. â° Du kien nhan: ~10 phut nua.';
    case 'completed':
      return 'âœ… Don hang da hoan tat. Cam on ban da dat mon!';
    case 'canceled':
      return 'âš ï¸ Don hang da bi huy. Neu ban khong thuc hien hanh dong nay, vui long lien he nhan vien.';
    default:
      return 'Trang thai don hang dang duoc cap nhat. Ban co the xem trong muc Tai khoan > Don hang.';
  }
};

const generateSmartReply = async (userId, content) => {
  const c = String(content || '').trim();
  const n = normalize(c);

  // Greetings
  if (containsAny(n, ['xin chao', 'chao', 'hello', 'hi'])) {
    return greetText();
  }

  // Working hours
  if (containsAny(n, ['mo cua', 'gio mo', 'gio dong', 'thoi gian lam viec', 'open', 'close'])) {
    return 'Quan mo cua tu 8:00 den 22:00 moi ngay.';
  }

  // Complaint: food cold / soggy
  if (containsAny(n, ['nguoi', 'lanh', 'khong nong', 'iu', 'iu xiu', 'miu'])) {
    return 'Rat xin loi ve trai nghiem chua tot ðŸ˜¥ Do an giao den tay ban phai luon nong hoi. Ban vui long cho toi xin Ma don (vd: #12345) hoac so dien thoai dat hang de ho tro ngay nhe!';
  }

  // Escalation intents
  if (containsAny(n, ['hoan tien', 'refund', 'gap nhan vien', 'noi chuyen voi nguoi', 'khong can voucher'])) {
    return 'Toi da ghi nhan yeu cau cua ban va se ket noi nhan vien ho tro ngay trong 1-2 phut. Vui long doi trong giay lat nhe!';
  }

  // Accept voucher intents
  if (containsAny(n, ['dong y', 'ok', 'oke']) && n.includes('voucher')) {
    return 'Tuyet voi! Voucher Giam 30% (toi da 50.000d) da duoc them vao muc Khuyen mai trong tai khoan cua ban.';
  }

  // Order tracking (by keyword)
  if (containsAny(n, ['don hang', 'bao gio', 'khi nao', 'trang thai'])) {
    try {
      const last = await Order.findOne({ where: { user_id: userId }, order: [["created_at", "DESC"]] });
      if (!last) {
        return 'Toi chua thay don hang gan day cua ban. Ban vui long cung cap Ma don (vd: #12345) hoac so dien thoai dat hang de kiem tra chi tiet nhe!';
      }
      return `Da tim thay don hang #${last.order_id}. ${buildOrderStatusText(last.status)}`;
    } catch {
      return 'Ban co the xem trang thai don hang trong muc Tai khoan > Don hang.';
    }
  }

  // If user provides phone or order code directly
  if (isPhoneLike(c) || isOrderCodeLike(c)) {
    try {
      const last = await Order.findOne({ where: { user_id: userId }, order: [["created_at", "DESC"]] });
      const base = last ? `Da tim thay don hang #${last.order_id}. ${buildOrderStatusText(last.status)}` : 'Toi se kiem tra thong tin don hang cua ban ngay.';
      return `${base}\n\nDe den bu su co, chung toi xin gui tang ban Voucher Giam 30% (toi da 50.000d) cho lan dat tiep theo. Ban co dong y nhan voucher khong?`;
    } catch {
      return 'Toi se kiem tra thong tin don hang va phan hoi ban trong giay lat nhe.';
    }
  }

  // Menu
  if (containsAny(n, ['menu', 'thuc don', 'co mon gi', 'goi mon'])) {
    return 'Ban co the xem menu va dat mon tai trang /menu.';
  }

  // Delivery / shipping
  if (containsAny(n, ['giao hang', 'ship', 'shipper', 'phi van chuyen', 'phi ship'])) {
    return 'Chung toi co giao hang qua doi tac. Phi giao hang duoc hien thi o buoc thanh toan tuy khu vuc.';
  }

  // Promotions
  if (containsAny(n, ['khuyen mai', 'ma giam gia', 'voucher', 'uu dai'])) {
    return 'Cac chuong trinh khuyen mai duoc cap nhat tai muc Khuyen Mai (News/Promotions).';
  }

  // Payment
  if (containsAny(n, ['thanh toan', 'momo', 'zalo pay', 'zalopay', 'vnpay', 'tien mat'])) {
    return 'Ho tro thanh toan tien mat khi nhan hang va mot so vi dien tu/online tuy khu vuc.';
  }

  // Address / location
  if (containsAny(n, ['dia chi', 'o dau', 'chi nhanh'])) {
    return 'Hien chung toi phuc vu online va takeaway trong khung gio 8:00-22:00. Thong tin chi nhanh se duoc cap nhat tren trang chu.';
  }

  // Customization intent (simple acknowledgment)
  if (containsAny(n, ['them', 'bot', 'khong ', 'khong ca chua', 'them pho mai', 'giam bot'])) {
    return 'Da ghi nhan yeu cau tuy chinh mon (vd: khong ca chua, them gap doi pho mai +15.000d). Ban vui long xac nhan lai trong trang chi tiet mon khi dat nhe!';
  }

  // Fallback
  if (c.length >= 2) {
    return 'Cam on ban da lien he! Nhan vien se ho tro ban som nhat.';
  }
  return null;
};

export {
  CustomerServiceError,
  listActiveProducts,
  listNews,
  getCustomerDashboard,
  listOrdersForCustomer,
  getCustomerOrder,
  createOrderForCustomer,
  cancelCustomerOrder,
  getProfile,
  createProfile,
  updateProfile,
  deleteProfile,
  // support
  listMySupportMessages,
  createSupportMessage,
  listMyConversationMessages,
  appendMyConversationMessage,
  // cart
  listCart,
  addItemToCart,
  updateCartItemQuantity,
  removeCartItem,
  clearCart
};





